#include <SPI.h>
#include <LoRa.h>

const int localAddress = 0x01;          // Endereço do receptor (este Arduino)
// Endereços dos transmissores
#define ADDRESS_1 0x02
#define ADDRESS_2 0x03
#define ADDRESS_3 0x04
#define ADDRESS_4 0x05
#define ADDRESS_5 0x06
#define ADDRESS_6 0x07
#define ADDRESS_7 0x08
#define ADDRESS_8 0x09
#define ADDRESS_9 0x0A

// Endereço do receptor (este dispositivo)
#define LOCAL_ADDRESS 0x01  //ENDEREÇO DO RECEPTOR=-
#define MAX_TRANSMISSOR 9   //COLOCAR O NUMERO DE TRANSMISSORES AQUI
int comandoIndex = 0;
char comandos[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I' };

unsigned long previousMillis = 0;
const long interval = 100
;  // Intervalo entre comandos

// Limpa caracteres indesejados
void LimparLixo(char* str) {
  int i = 0, j = 0;
  while (str[i] != '\0') {
    if (isalnum(str[i]) || str[i] == '-' || isspace(str[i])) {
      str[j++] = str[i];
    }
    i++;
  }
  str[j] = '\0';
}

// Processa a mensagem já limpa e separada
void ProcessarMensagem(char* msg) {
  LimparLixo(msg);

  char* token = strtok(msg, "-");
  if (token == NULL) return;

  int tipo = atoi(token);  // 1º campo

  token = strtok(NULL, "-");  // 2º campo: ID
  if (token == NULL) return;
  char id[50];
  strcpy(id, token);

  token = strtok(NULL, "-");  // 3º campo: status
  if (token == NULL) return;
  char status[50];
  strcpy(status, token);

  Serial.print(tipo);
  Serial.print("-");
  Serial.print(id);
  Serial.print("-");
  Serial.println(status);
  //Serial.println(msg);
}

// Envia mensagem via LoRa
void sendLoRaMessage(int destinationAddress, String message) {
  LoRa.beginPacket();
  LoRa.write(destinationAddress);
  LoRa.write(localAddress);
  LoRa.print(message);
  LoRa.endPacket();
}

// Verifica se a mensagem recebida é válida
bool isValidMessage(String message) {
  for (int i = 0; i < message.length(); i++) {
    char c = message.charAt(i);
    if (!(isalnum(c) || c == '\n' || c == '-' || c == 'x')) {
      return false;
    }
  }
  return true;
}

void enviaComando(byte endereco, char comando) {
  LoRa.beginPacket();
  LoRa.write(endereco);       // destinatário
  LoRa.write(LOCAL_ADDRESS);  // remetente
  LoRa.write(comando);        // conteúdo
  LoRa.endPacket();
}

void setup() {
  Serial.begin(9600);
  Serial.flush();

  LoRa.setPins(10, 9, 5);
  if (!LoRa.begin(915E6)) {
    Serial.println("Falha ao iniciar o LoRa!");
    //while (1)
      ;
  }
}

void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;

    char comando = comandos[comandoIndex];
    byte destinatario;

    switch (comandoIndex) {
      case 0: destinatario = ADDRESS_1; break;
      case 1: destinatario = ADDRESS_2; break;
      case 2: destinatario = ADDRESS_3; break;
      case 3: destinatario = ADDRESS_4; break;
      case 4: destinatario = ADDRESS_5; break;
      case 5: destinatario = ADDRESS_6; break;
      case 6: destinatario = ADDRESS_7; break;
      case 7: destinatario = ADDRESS_8; break;
      case 8: destinatario = ADDRESS_9; break;
    }
    enviaComando(destinatario, comando);
    comandoIndex = (comandoIndex + 1) % MAX_TRANSMISSOR;  //Essa linha incrementa comandoIndex em 1 , volta para 0" quando chegar a 4.
  }

  int packetSize = LoRa.parsePacket();
  if (packetSize) {
    int receivedDestinationAddress = LoRa.read();
    int receivedSenderAddress = LoRa.read();

    String packetContent = "";
    while (LoRa.available()) {
      char c = (char)LoRa.read();
      if (c == '\n') break;
      packetContent += c;
    }

    if (receivedDestinationAddress == localAddress && isValidMessage(packetContent)) {
      String linha = String(receivedSenderAddress, HEX) + "-" + packetContent;
      //Serial.println(linha);

      char buffer[100];
      linha.toCharArray(buffer, sizeof(buffer));
      ProcessarMensagem(buffer);
    }
  }
}
