//******************************TRANSMISSOR****************************************************//
//  Sitema para monitoramento de pulseriras Antiestáticas
//  Data: 13/08/2024
//  Atualização: 01/06/2025
//  Versão: 1.2
//  Autor: Elvis Jardim Maués
//********************************************************************************************//

#include <EEPROM.h>
#include <SPI.h>
#include <LoRa.h>
#include <Arduino.h>
#include <DFRobot_GM60.h>
#include <SoftwareSerial.h>

#define AMOSTRAS 1

#define SS 10   // Chip Select pin
#define RST 9   // Reset pin
#define DIO5 5  // DIO5 pin

#define DATA0 2
#define DATA1 3

#define RX 4
#define TX 6

SoftwareSerial serialLeitorBarcode(RX, TX);  //RX, TX para leitor de códigos
#define FPSerial serialLeitorBarcode
DFRobot_GM60_UART gm60;  // Instância do leitor de códigos

const int pinEntrada = A0;            // Define a entrada analógica usada para a medição
const int localAddress = 0x09;        // Endereço do transmissor
const int destinationAddress = 0x01;  // Endereço do receptor

char Envio[10] = "I";

char facilityCode_formatado[4];  // Buffer para armazenar o valor formatado
char carCode_formatado[6];       // Buffer para armazenar o valor formatado

char tagId[20];            // Ajuste o tamanho conforme necessário
String wristStrapID = "";  // Código único da pulseira

float tensaoMedida = 0.0;

unsigned long lastReceiveTime = 0;
const unsigned long timeout = 5000;  // Tempo de espera em milissegundos
int flag = 0, var;

//**************************RFID********************************************************//
#define MAX_BITS 100            // Numero Máximo de Bits
#define WEIGAND_WAIT_TIME 3000  // Tempo de espera por outro pulso weigand.

unsigned char databits[MAX_BITS];  // armazena todos os bits de dados
unsigned char bitCount;            // Numero de bits coletados atualmente
unsigned char flagDone;            // fica baixo quando os dados estão sendo capturados
unsigned int weigand_counter;      // contagem regressiva até assumirmos que não há mais bits

unsigned long facilityCode = 0;  // código de facilidade decodificado
unsigned long cardCode = 0;      // código do cartão decodificado

volatile bool newCardRead = false;        // Flag para indicar que um novo cartão foi lido
volatile unsigned long timerCounter = 0;  // Contador do temporizador

unsigned long lastSendTime = 0;        // Tempo da última vez que os dados foram enviados
const unsigned long sendInterval = 0;  // Intervalo de envio em milissegundos

int etapa = 1;
// interrupção que acontece quando INTO fica baixo (bit 0)
void ISR_INT0() {
  bitCount++;
  flagDone = 0;
  weigand_counter = WEIGAND_WAIT_TIME;
}

// interrupção que acontece quando INT1 fica baixo (bit 1)
void ISR_INT1() {
  databits[bitCount] = 1;
  bitCount++;
  flagDone = 0;
  weigand_counter = WEIGAND_WAIT_TIME;
}
//**************************************************************************************//
// Interrupção de temporizador que ocorre a cada milissegundo
ISR(TIMER1_COMPA_vect) {
  timerCounter++;  // Incrementa o contador do temporizador
}

void setup() {
  Serial.begin(115200);
  
  //**************************RFID********************************************************//
  pinMode(DATA0, INPUT);  // DATA0 (INT0)
  pinMode(DATA1, INPUT);  // DATA1 (INT1)

  // vincula as funções ISR à borda descendente de INTO e INT1
  attachInterrupt(0, ISR_INT0, FALLING);
  attachInterrupt(1, ISR_INT1, FALLING);


  weigand_counter = WEIGAND_WAIT_TIME;
  //**************************************************************************************//

  LoRa.setPins(SS, RST, DIO5);  // ss, RST, DIO2

  resetLoRa();  // Reseta o LoRa na inicialização

  if (!LoRa.begin(915E6)) {
    Serial.println("Starting LoRa failed!");
    while (1)
      ;
  }

  lerTagIdDaEEPROM(tagId);  // Lê o tagId da EEPROM na inicialização

  setupTimer1();
}

// Configura o Timer1 para gerar uma interrupção a cada milissegundo
void setupTimer1() {
  noInterrupts();                       // Desabilita as interrupções
  TCCR1A = 0;                           // Limpa o registrador TCCR1A
  TCCR1B = 0;                           // Limpa o registrador TCCR1B
  TCNT1 = 0;                            // Inicializa o contador a 0
  OCR1A = 15999;                        // Comparação a cada 1 ms (16000000/1000/64 - 1)
  TCCR1B |= (1 << WGM12);               // Configura o modo CTC (Clear Timer on Compare Match)
  TCCR1B |= (1 << CS11) | (1 << CS10);  // Prescaler 64
  TIMSK1 |= (1 << OCIE1A);              // Habilita a interrupção do comparador A
  interrupts();                         // Habilita as interrupções
}

float lePorta(uint8_t portaAnalogica) {
  float total = 0;
  for (int i = 0; i < AMOSTRAS; i++) {
    total += analogRead(portaAnalogica);
    //delay(1);
  }
  return total / AMOSTRAS * (5.0 / 1023.0);
}

void (*resetFunc)(void) = 0;  //declare reset function @ address 0

void loop() {
  if (Serial.available()) {
    var = Serial.read();

    if (var == 'v')  //COMANDO PARA MAPEAR IDENTIFICAR CAIXINHA
    {
      Serial.print("Endereço: ");
      if (localAddress < 0x10) Serial.print("0");
      Serial.print(localAddress, HEX);

      Serial.print(" | Envio: ");
      Serial.println(Envio);
    }
  }

  // Exemplo: Reseta o LoRa se não houver comunicação por um tempo

  if ((millis() - lastReceiveTime > timeout)) {
    // Comunicação perdida
    //Serial.println("Comunicação perdida!");
    resetLoRa();
    resetFunc();
  }
  //**************************RFID********************************************************//
  // Isso espera para garantir que não haja mais pulsos de dados antes de processar os dados
  switch (etapa) {
    case 1:
      if (!flagDone) {
        if (--weigand_counter == 0)
          flagDone = 1;
      }

      // se tivermos bits e o contador weigand saiu
      if (bitCount > 0 && flagDone) {
        unsigned char i;

        if (bitCount == 35) {
          for (i = 2; i < 14; i++) {
            facilityCode <<= 1;
            facilityCode |= databits[i];
          }

          // card code = bits 15 to 34
          for (i = 14; i < 34; i++) {
            cardCode <<= 1;
            cardCode |= databits[i];
          }

          printBits();
          salvarTagIdNaEEPROM(tagId);  // Salva o tagId na EEPROM
        } else if (bitCount == 26) {
          for (i = 1; i < 9; i++) {
            facilityCode <<= 1;
            facilityCode |= databits[i];
          }

          // card code = bits 10 to 23
          for (i = 9; i < 25; i++) {
            cardCode <<= 1;
            cardCode |= databits[i];
          }

          printBits();
          salvarTagIdNaEEPROM(tagId);  // Salva o tagId na EEPROM
          etapa = 2;
        } else {
          // você pode adicionar outros formatos se quiser!
          Serial.println("Unable to decode.");
        }

        // cleanup and get ready for the next card
        bitCount = 0;
        facilityCode = 0;
        cardCode = 0;
        for (i = 0; i < MAX_BITS; i++) {
          databits[i] = 0;
        }
      }
      break;

    case 2:
      serialLeitorBarcode.begin(9600);
      gm60.begin(serialLeitorBarcode);
      gm60.reset();
      gm60.encode(gm60.eUTF8);
      gm60.setupCode(true, true);
      gm60.setIdentify(gm60.eEnableAllBarcode);
      //wristStrapID = gm60.detection();
      while (wristStrapID == "" || wristStrapID == "null") {
        delay(50);
        /*if (serialLeitorBarcode.isListening()) {
          Serial.println("Escutando");
        }*/
        wristStrapID = gm60.detection();
        //c
      }
      serialLeitorBarcode.end();
      etapa = 1;
      break;
  }

  // Verifica se há um pacote recebido
  int packetSize = LoRa.parsePacket();
  if (packetSize) {
    lastReceiveTime = millis();  // Atualiza o tempo da última mensagem recebida

    int receivedDestinationAddress = LoRa.read();
    int receivedSenderAddress = LoRa.read();

    char packetContent[128];  // Tamanho máximo da mensagem
    int contentIndex = 0;

    while (LoRa.available()) {
      char c = (char)LoRa.read();
      if (c == '\n' || contentIndex >= sizeof(packetContent) - 1) break;
      packetContent[contentIndex++] = c;
    }
    packetContent[contentIndex] = '\0';  // Finaliza string

    // Verifica se o conteúdo do pacote é igual ao que esperamos
    if (packetContent == Envio) {
      tensaoMedida = lePorta(A0);
      //Serial.println(tensaoMedida);

      LoRa.beginPacket();
      LoRa.write(destinationAddress);  // Endereço do receptor
      LoRa.write(localAddress);        // Endereço do transmissor
      LoRa.print(tagId);
      //LoRa.print(tensaoMedida > 0.5 ? "-conectada" : "-desconectada");
      LoRa.print(tensaoMedida > 0.5 ? "-1" : "-0");
      LoRa.print("\n");  // Adiciona um terminador de linha
      LoRa.endPacket();
    }
  }
}

void printBits() {

  // Formatação do valor com zeros à esquerda
  sprintf(facilityCode_formatado, "%03lu", facilityCode);
  //Serial.println(facilityCode_formatado);

  // Formatação do valor com zeros à esquerda
  sprintf(carCode_formatado, "%05lu", cardCode);
  //Serial.println(carCode_formatado);

  // Formatação do valor com zeros à esquerda
  sprintf(tagId, "%s%s", facilityCode_formatado, carCode_formatado);

  //Serial.println(tagId);   //HABILTAR PAR VISUALIZAR LEITURA DO CRACHA
}

// Função de reset do LoRa
void resetLoRa() {
  digitalWrite(RST, LOW);   // Puxa o pino de reset para baixo (LOW)
  delay(0.1);               // Espera 10ms
  digitalWrite(RST, HIGH);  // Puxa o pino de reset para cima (HIGH)
  delay(5);                 // Espera mais 10ms para estabilizar

  flag = 0;

  // Re-inicializa o LoRa após o reset
  if (!LoRa.begin(915E6)) {
    Serial.println("Falha ao iniciar o LoRa após o reset.");
    while (1)
      ;
  }
}

void salvarTagIdNaEEPROM(const char* tagId) {
  // Limpa a EEPROM antes de gravar
  for (int i = 0; i < 20; i++) {
    EEPROM.write(i, 0);
  }

  // Grava o tagId na EEPROM
  for (int i = 0; i < 20; i++) {
    EEPROM.write(i, tagId[i]);
  }
}

void lerTagIdDaEEPROM(char* tagId) {
  // Lê o tagId da EEPROM
  for (int i = 0; i < 20; i++) {
    tagId[i] = EEPROM.read(i);
  }
  tagId[19] = '\0';  // Garante que a string seja terminada com nulo
}
